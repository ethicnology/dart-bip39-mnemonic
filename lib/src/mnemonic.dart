// ignore_for_file: non_constant_identifier_names

import 'dart:math';

import 'crypto.dart';
import 'language.dart';
import 'bits.dart';
import 'exceptions.dart';
import 'mnemonic_length.dart';

/// BIP39: A mnemonic sentence is superior for human interaction compared to the handling of raw binary or hexadecimal representations of a wallet seed.
class Mnemonic {
  /// BIP39: The mnemonic must encode entropy in a multiple of 32 bits.
  /// With more entropy security is improved but the sentence length increases.
  /// The allowed size of _ENT is 128-256 bits.
  late List<int> entropy;

  /// The language affect the sentence and the seed generation.
  /// BIP39: Since the vast majority of BIP39 wallets supports only the English wordlist, it is strongly discouraged to use non-English wordlists for generating the mnemonic sentences. If you still feel your application really needs to use a localized wordlist, use one of the following instead of inventing your own.
  Language language;

  /// Passphrase is only used on seed generation.
  /// BIP39:  A user may decide to protect their mnemonic with a passphrase.
  /// If a passphrase is not present, an empty string "" is used instead.
  String passphrase;

  /// BIP39: We refer to the initial entropy length as ENT.
  int get _ENT => entropy.length * 8;
  late MnemonicLength length;

  /// BIP39: The checksum length (CS)
  int get _CS => _ENT ~/ 32;

  /// BIP39: The length of the generated mnemonic sentence (MS) in words.
  int get _MS => (_ENT + _CS) ~/ 11;

  /// BIP39: A checksum is generated by taking the first _ENT / 32 bits of its SHA256 hash.
  Bits get _checksum {
    final hash = sha256(entropy);
    return BitsExtension.fromBytes(hash).sublist(0, _CS);
  }

  /// Returns entropy + checksum in binary string.
  /// BIP39: This checksum is appended to the end of the initial entropy.
  Bits get _binary => BitsExtension.fromBytes(entropy) + _checksum;

  /// Returns mnemonic indexes.
  /// BIP39: Next, these concatenated bits are split into groups of 11 bits, each encoding a number from 0-2047, serving as an index into a wordlist.
  List<int> get _indexes {
    List<int> indexes = [];
    for (var i = 0; i < _binary.length; i += 11) {
      final bit = _binary.sublist(i, i + 11).toBinaryString();
      indexes.add(int.parse(bit, radix: 2));
    }
    if (indexes.length == _MS) return indexes;
    throw MnemonicIndexesLengthException(indexes.length);
  }

  /// BIP39: Finally, we convert these numbers (indexes) into words.
  List<String> get words {
    List<String> result = [];
    List<String> wordlist = language.list;
    for (int index in _indexes) {
      result.add(wordlist[index]);
    }
    return result;
  }

  /// BIP39: Use the joined words as a mnemonic sentence.
  String get sentence => words.join(language.separator);

  /// BIP39: To create a binary seed from the mnemonic, we use the PBKDF2 function with a mnemonic sentence (in UTF-8 NFKD) used as the password and the string "mnemonic" + passphrase (again in UTF-8 NFKD) used as the salt.
  /// The iteration count is set to 2048 and HMAC-SHA512 is used as the pseudo-random function.
  /// The length of the derived key is 512 bits (= 64 bytes). This seed can be later used to generate deterministic wallets using BIP-0032 or similar methods.
  List<int> get seed {
    var normalize = sentence.replaceAll(language.separator, '\u{0020}');
    return pbkdf2(normalize, passphrase: passphrase);
  }

  /// Constructs Mnemonic from entropy bytes.
  Mnemonic(this.entropy, this.language, {this.passphrase = ""})
      : length = MnemonicLength.fromEntropy(entropy.length * 8);

  /// Constructs Mnemonic from one of these entropy lengths: [128, 160, 192, 224, 256]
  Mnemonic.generate(
    this.language, {
    this.passphrase = "",
    this.length = MnemonicLength.words24,
  }) {
    var random = Random.secure();
    entropy = List<int>.generate(
      length.bytes,
      (i) => random.nextInt(256),
    );
  }

  /// Constructs Mnemonic from a sentence by retrieving the original entropy.
  Mnemonic.fromSentence(String sentence, this.language,
      {this.passphrase = ""}) {
    try {
      final words = sentence.split(language.separator);
      length = MnemonicLength.fromWords(words.length);

      // convert words to bits to remove the checksum.
      final bits = BitsExtension.fromWords(words, language);

      // remove checksum from bits.
      final bitsEntropy = bits.sublist(0, bits.length - length.checksum);
      final extractedChecksum = bits.sublist(bits.length - length.checksum);

      // converts bits entropy back to bytes.
      entropy = bitsEntropy.toBytes();

      if (_checksum.toBinaryString() != extractedChecksum.toBinaryString()) {
        throw MnemonicInvalidChecksumException(sentence);
      }
    } catch (_) {
      rethrow;
    }
  }

  /// Constructs Mnemonic from a words, this new method use named parameters, the language is English by default.
  Mnemonic.fromWords({
    required List<String> words,
    Language language = Language.english,
    String passphrase = '',
  }) : this.fromSentence(
          words.join(language.separator),
          language,
          passphrase: passphrase,
        );
}
